# 第7章 范围和视图的工具

## 7.1 范围作为视图的实用工具

### 7.1.1 `std::views::all()`

`std::views::all(rg)`:
+ 如果`rg`已经是视图, 则为`rg`的副本
+ 否则, `rg`的`std::ranges::ref_view`是一个左值
+ 否则, 若`rg`的`std::ranges::owned_view`是右值(未命名的临时对象或用`std::move`标记的范围对象)

#### 7.1.1.1 std::views::all_t<>类型

```cpp
std::vector<int> v{0, 8, 15, 47, 11, -1, 13};
std::views::all_t<decltype(v)> a1{v}; // ERROR
std::views::all_t<decltype(v)&> a2{v}; // ref_view<vector<int>>
std::views::all_t<decltype(v)&&> a3{v}; // ERROR
std::views::all_t<decltype(v)> a4{std::move(v)}; // owning_view<vector<int>>
std::views::all_t<decltype(v)&> a5{std::move(v)}; // ERROR
std::views::all_t<decltype(v)&&> a6{std::move(v)}; // owning_view<vector<int>>

```
### 7.1.2 `std::views::counted()`
`std::views::counted(beg, sz)`创建一个以`beg`开头的范围的前`sz`个元素, **由开发者保证`beg`和`sz`是有效的**.

注意, 为了性能, `std::views::counted()`的返回类型有所不一样:
+ `contiguous_itertor` 则返回 `std::span`, 其实就是内存连续的的容器,适用于`std::vector`,`std::array`, 原始指针, 原始数组, 迭代器
+ `std::random_access_iterator`则返回`std::views::subrange`且迭代器是`std::random_access_iterator`,适用于`std::deque`
+ 否则返回`std::views::subrange`, 以`std::default_sentinel_t`类型的哨兵作为结束

### 7.1.3 `std::views::common()`
范围适配器`std::views::common()`为传递的范围生成一个**具有统一类型**的视图, 用于开始迭代器和哨兵(结束迭代器). 其行为类似于范围适配器 `std::views::all()`，若其迭代器具有不同的类型，则会从传递的参数创建`std::ranges::common_view`


## 7.2 新迭代器类别
















